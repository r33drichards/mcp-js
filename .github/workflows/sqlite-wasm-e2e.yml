name: SQLite WASM E2E Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  sqlite-wasm-e2e:
    name: SQLite WASM E2E
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          extra-conf: |
            sandbox = relaxed

      - uses: DeterminateSystems/flake-checker-action@main

      - name: Build SQLite WASM
        run: nix build .#sqlite-wasm --print-build-logs -L

      - name: Build mcp-v8
        run: nix build .#default --print-build-logs -L

      - name: Run SQLite WASM E2E test
        run: |
          WASM_PATH=$(nix build .#sqlite-wasm --print-out-paths)/sqlite3.wasm
          SERVER_BIN=$(nix build .#default --print-out-paths)/bin/server

          echo "WASM: $WASM_PATH"
          echo "Server: $SERVER_BIN"

          # Start server in HTTP mode with the SQLite WASM module
          $SERVER_BIN --stateless --http-port 8080 \
            --wasm-module sqlite="$WASM_PATH" \
            --heap-memory-max 64 &
          SERVER_PID=$!

          # Ensure we always clean up the server process
          cleanup() { kill $SERVER_PID 2>/dev/null || true; }
          trap cleanup EXIT

          # Wait for server to be ready (up to 30s)
          for i in $(seq 1 30); do
            HTTP_CODE=$(curl -s --max-time 10 -o /dev/null -w '%{http_code}' \
              http://localhost:8080/api/exec \
              -H 'Content-Type: application/json' \
              -d '{"code": "1+1"}' 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "202" ] || [ "$HTTP_CODE" = "200" ]; then
              echo "Server is ready (HTTP $HTTP_CODE)"
              break
            fi
            sleep 1
          done

          # Run the SQLite WASM example â€” submit for async execution
          HTTP_CODE=$(curl -s -o /tmp/submit.json -w '%{http_code}' \
            http://localhost:8080/api/exec \
            -H 'Content-Type: application/json' \
            -d "$(jq -Rs '{code: .}' < examples/sqlite-wasm/example.js)")

          echo "Submit HTTP status: $HTTP_CODE"
          cat /tmp/submit.json

          if [ "$HTTP_CODE" != "202" ]; then
            echo "ERROR: Server returned HTTP $HTTP_CODE (expected 202)"
            cat /tmp/submit.json
            exit 1
          fi

          EXEC_ID=$(cat /tmp/submit.json | jq -r '.execution_id')
          echo "Execution ID: $EXEC_ID"

          # Poll for completion (up to 60s for WASM compilation)
          for i in $(seq 1 60); do
            STATUS_RESP=$(curl -s http://localhost:8080/api/executions/${EXEC_ID})
            STATUS=$(echo "$STATUS_RESP" | jq -r '.status')
            if [ "$STATUS" = "Completed" ] || [ "$STATUS" = "completed" ]; then
              echo "Execution completed"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "failed" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "ERROR: Execution $STATUS"
              echo "$STATUS_RESP"
              exit 1
            fi
            sleep 1
          done

          # Get the result
          RESULT=$(echo "$STATUS_RESP" | jq -r '.result')
          echo "Result: $RESULT"

          # Parse and verify the output
          OUTPUT="$RESULT"
          echo "Output: $OUTPUT"

          # Verify we got 3 users back
          echo "$OUTPUT" | jq -e '.users | length == 3'

          # Verify users are sorted by age (Bob=25, Alice=30, Charlie=35)
          echo "$OUTPUT" | jq -e '.users[0].name == "Bob"'
          echo "$OUTPUT" | jq -e '.users[1].name == "Alice"'
          echo "$OUTPUT" | jq -e '.users[2].name == "Charlie"'

          # Verify stats
          echo "$OUTPUT" | jq -e '.stats.count == 3'
          echo "$OUTPUT" | jq -e '.stats.avg_age == 30'

          echo "SQLite WASM E2E test passed!"
